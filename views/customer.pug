doctype html
head
  meta(charset='utf-8')
  title The Nature Takeover | Interactive
  link(rel='stylesheet' href='/static/css/client.css')
script(src='/static/js/socket.io.js' charset='utf-8')
script(src='/static/js/p5.js' charset='utf-8')
script(src='https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js')
script(type='text/javascript').
  // Set initial / global values
  let socket
  var x = 0
  var y = 0
  var velocityX = 0;
  var velocityY = 0;
  var angle1 = 0.0;
  var segLength = 50;
  var targetX;
  var targetY;
  var smoothTargetX;
  var smoothTargetY;
  let imgLoaded = false
  let img
  let imgUrl
  let canvas
  var idleTime = 0;
 // Add after variable declarations
  var beetleFrameOffsets = [
    [0, 0],   // Frame 0
    [2, 1],   // Frame 1
    [1, 0],   // Frame 2
    [0, 2],   // Frame 3
    [-1, 1],  // Frame 4
    [1, -1],  // Frame 5
    [0, 0]    // Frame 6
  ];
  // Fix for animation timing
  var lastFrameTime = null;
  var deltaTime = 16.67; // Default to ~60fps

  // Random color tint for this user (not black)
  let spriteTint;
  function getRandomTintColor() {
    // Avoid black: pick hue, high saturation, high brightness
    let h = Math.floor(Math.random() * 360);
    let s = 80 + Math.random() * 20; // 80-100%
    let l = 45 + Math.random() * 30; // 45-75%
    // Convert HSL to RGB
    function hslToRgb(h, s, l) {
      s /= 100; l /= 100;
      let c = (1 - Math.abs(2 * l - 1)) * s;
      let x = c * (1 - Math.abs((h / 60) % 2 - 1));
      let m = l - c/2, r=0, g=0, b=0;
      if (h < 60) { r = c; g = x; }
      else if (h < 120) { r = x; g = c; }
      else if (h < 180) { g = c; b = x; }
      else if (h < 240) { g = x; b = c; }
      else if (h < 300) { r = x; b = c; }
      else { r = c; b = x; }
      return [Math.round((r + m) * 255), Math.round((g + m) * 255), Math.round((b + m) * 255)];
    }
    return hslToRgb(h, s, l);
  }
  spriteTint = getRandomTintColor();

  // Advanced realistic movement variables
  var insectType = 'yellow_bee';
  var spriteSheet = null;
  var spriteFrames = [];
  var currentFrame = 0;
  var frameCounter = 0;
  var animationFrame = 0;
  var isMoving = false;
  var movementSpeed = 0;

  // Realistic behavior variables
  var behaviorState = 'exploring'; // exploring, hovering, resting, accelerating
  var stateTimer = 0;
  var wingPhase = 0;
  var bodyTilt = 0;
  var hoverOffset = { x: 0, y: 0 };
  var momentumX = 0, momentumY = 0;
  var acceleration = { x: 0, y: 0 };
  var lastVelocityX = 0, lastVelocityY = 0;
  var groundContact = false;
  var walkPhase = 0;
  var antennaeAngle = 0;
  var bodyWeight = 0;

  // BASE CONFIGS - for dynamically generating new insect variations
  var baseSpriteConfigs = {
    bee: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'bee_sprite.png', // The filename of the sprite sheet image
      frameWidth: 150, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 2, // The number of frames horizontally in the sprite sheet
      framesY: 1, // The number of frames vertically in the sprite sheet
      totalFrames: 2, // The total number of frames in the sprite sheet
      wingBeatFreq: 3680, // The frequency of wing beats per second (Hz). Higher is faster
      wingBeatAmplitude: 0.15, // The amplitude of the wing beat motion
      hoverJitter: 2.5, // The amount of random "jitter" when hovering. Higher is more erratic
      hoverFreq: 0.3, // The frequency of the hover jitter
      liftCoefficient: 0.8, // The amount of lift generated by the wings
      dragCoefficient: 0.12, // The air resistance affecting the bee
      maxTilt: 25, // The maximum angle the bee can tilt during flight (in degrees)
      animationSpeed: 320, // The speed of the sprite animation playback
      idleSpeed: 240, // The speed of the sprite animation when idle
      easing: 0.18, // The easing factor for smooth movement. Lower is smoother but slower to react
      friction: 0.82, // The friction factor that slows down the insect. Closer to 1 is less friction
      maxSpeed: 480, // The maximum movement speed
      acceleration: 2.0 // The acceleration rate
    },
    butterfly: {
      useSpriteSheet: false, // Whether to use a sprite sheet for animation (false for butterflies)
      wingFlapSpeed: 0.10, // The speed of the wing flapping animation
      wingFlapIntensity: 0.35, // The intensity or amplitude of the wing flap
      bodyFloatSpeed: 0.05, // The speed of the vertical floating motion
      bodyFloatIntensity: 10, // The intensity or amplitude of the vertical floating motion
      glideAmplitude: 12, // The amplitude of the side-to-side gliding motion
      scaleVariation: 0.20, // The amount of random size variation during flight
      rotationVariation: 6, // The amount of random rotation variation during flight
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.92, // The friction that slows down the insect
      maxSpeed: 200, // The maximum movement speed
      acceleration: 0.75 // The acceleration rate
    },
    beetle: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'beetle_sprite.png', // The filename of the sprite sheet image
      frameWidth: 120, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 3, // The number of frames horizontally in the sprite sheet
      framesY: 3, // The number of frames vertically in the sprite sheet
      totalFrames: 7, // The total number of frames in the sprite sheet
      walkCycleLength: 1.5, // The duration of a full walk cycle
      legPhases: [0, 0.5, 0.25, 0.75, 0.125, 0.625], // The timing phases for each of the 6 legs
      bodyRockAmplitude: 6, // The amplitude of the body's side-to-side rocking motion when walking
      stepHeight: 4, // The height of the leg lift during a step
      groundFriction: 0.8, // The friction between the legs and the ground
      bodyWeight: 1.2, // The perceived weight of the insect, affecting its movement
      centerOfMass: 0.6, // The center of mass, affecting balance
      legStrength: 0.8, // The strength of the leg push
      stabilityFactor: 0.7, // The stability of the insect when moving
      animationSpeed: 8, // The playback speed of the walking animation
      idleSpeed: 0, // The playback speed of the animation when idle (usually 0 for walking)
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.65, // The friction that slows down the insect
      maxSpeed: 1200, // The maximum movement speed
      acceleration: 3.0 // The acceleration rate
    },
    weavil: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'beetle_sprite.png', // The filename of the sprite sheet image
      frameWidth: 120, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 3, // The number of frames horizontally in the sprite sheet
      framesY: 3, // The number of frames vertically in the sprite sheet
      totalFrames: 7, // The total number of frames in the sprite sheet
      walkCycleLength: 1.8, // The duration of a full walk cycle
      legPhases: [0, 0.6, 0.3, 0.9, 0.15, 0.75], // The timing phases for each of the 6 legs
      bodyRockAmplitude: 4, // The amplitude of the body's side-to-side rocking motion when walking
      stepHeight: 3, // The height of the leg lift during a step
      groundFriction: 0.9, // The friction between the legs and the ground
      bodyWeight: 0.8, // The perceived weight of the insect, affecting its movement
      centerOfMass: 0.7, // The center of mass, affecting balance
      legStrength: 0.6, // The strength of the leg push
      stabilityFactor: 0.8, // The stability of the insect when moving
      animationSpeed: 6, // The playback speed of the walking animation
      idleSpeed: 0, // The playback speed of the animation when idle (usually 0 for walking)
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.6, // The friction that slows down the insect
      maxSpeed: 800, // The maximum movement speed
      acceleration: 3.5 // The acceleration rate
    }
  };

  // Sprite sheet configurations with realistic physics
  var spriteConfigs = {
    // BEES - Will be dynamically populated
    yellow_bee: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'bee_sprite.png', // The filename of the sprite sheet image
      frameWidth: 150, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 2, // The number of frames horizontally in the sprite sheet
      framesY: 1, // The number of frames vertically in the sprite sheet
      totalFrames: 2, // The total number of frames in the sprite sheet
      wingBeatFreq: 3680, // The frequency of wing beats per second (Hz). Higher is faster
      wingBeatAmplitude: 0.15, // The amplitude of the wing beat motion
      hoverJitter: 2.5, // The amount of random "jitter" when hovering. Higher is more erratic
      hoverFreq: 0.3, // The frequency of the hover jitter
      liftCoefficient: 0.8, // The amount of lift generated by the wings
      dragCoefficient: 0.12, // The air resistance affecting the bee
      maxTilt: 25, // The maximum angle the bee can tilt during flight (in degrees)
      animationSpeed: 320, // The speed of the sprite animation playback
      idleSpeed: 240, // The speed of the sprite animation when idle
      easing: 0.18, // The easing factor for smooth movement. Lower is smoother but slower to react
      friction: 0.82, // The friction factor that slows down the insect. Closer to 1 is less friction
      maxSpeed: 480, // The maximum movement speed
      acceleration: 2.0 // The acceleration rate
    },
    purple_bee: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'bee_sprite.png', // The filename of the sprite sheet image
      frameWidth: 150, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 2, // The number of frames horizontally in the sprite sheet
      framesY: 1, // The number of frames vertically in the sprite sheet
      totalFrames: 2, // The total number of frames in the sprite sheet
      wingBeatFreq: 3680, // The frequency of wing beats per second (Hz). Higher is faster
      wingBeatAmplitude: 0.15, // The amplitude of the wing beat motion
      hoverJitter: 2.5, // The amount of random "jitter" when hovering. Higher is more erratic
      hoverFreq: 0.3, // The frequency of the hover jitter
      liftCoefficient: 0.8, // The amount of lift generated by the wings
      dragCoefficient: 0.12, // The air resistance affecting the bee
      maxTilt: 25, // The maximum angle the bee can tilt during flight (in degrees)
      animationSpeed: 320, // The speed of the sprite animation playback
      idleSpeed: 240, // The speed of the sprite animation when idle
      easing: 0.18, // The easing factor for smooth movement. Lower is smoother but slower to react
      friction: 0.82, // The friction factor that slows down the insect. Closer to 1 is less friction
      maxSpeed: 480, // The maximum movement speed
      acceleration: 2.0 // The acceleration rate
    },
    blue_bee: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'bee_sprite.png', // The filename of the sprite sheet image
      frameWidth: 150, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 2, // The number of frames horizontally in the sprite sheet
      framesY: 1, // The number of frames vertically in the sprite sheet
      totalFrames: 2, // The total number of frames in the sprite sheet
      wingBeatFreq: 4000, // The frequency of wing beats per second (Hz). Higher is faster
      wingBeatAmplitude: 0.18, // The amplitude of the wing beat motion
      hoverJitter: 3.0, // The amount of random "jitter" when hovering. Higher is more erratic
      hoverFreq: 0.35, // The frequency of the hover jitter
      liftCoefficient: 0.85, // The amount of lift generated by the wings
      dragCoefficient: 0.15, // The air resistance affecting the bee
      maxTilt: 28, // The maximum angle the bee can tilt during flight (in degrees)
      animationSpeed: 400, // The speed of the sprite animation playback
      idleSpeed: 288, // The speed of the sprite animation when idle
      easing: 0.18, // The easing factor for smooth movement. Lower is smoother but slower to react
      friction: 0.8, // The friction factor that slows down the insect. Closer to 1 is less friction
      maxSpeed: 560, // The maximum movement speed
      acceleration: 2.25 // The acceleration rate
    },
    
    // BUTTERFLIES - Graceful mathematical animation (FINE-TUNED FOR SMOOTHNESS)
    red_butterfly: {
      useSpriteSheet: false, // Whether to use a sprite sheet for animation (false for butterflies)
      wingFlapSpeed: 0.10, // The speed of the wing flapping animation
      wingFlapIntensity: 0.35, // The intensity or amplitude of the wing flap
      bodyFloatSpeed: 0.05, // The speed of the vertical floating motion
      bodyFloatIntensity: 10, // The intensity or amplitude of the vertical floating motion
      glideAmplitude: 12, // The amplitude of the side-to-side gliding motion
      scaleVariation: 0.20, // The amount of random size variation during flight
      rotationVariation: 6, // The amount of random rotation variation during flight
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.92, // The friction that slows down the insect
      maxSpeed: 200, // The maximum movement speed
      acceleration: 0.75 // The acceleration rate
    },
    purple_butterfly: {
      useSpriteSheet: false, // Whether to use a sprite sheet for animation (false for butterflies)
      wingFlapSpeed: 0.08, // The speed of the wing flapping animation
      wingFlapIntensity: 0.30, // The intensity or amplitude of the wing flap
      bodyFloatSpeed: 0.04, // The speed of the vertical floating motion
      bodyFloatIntensity: 8, // The intensity or amplitude of the vertical floating motion
      glideAmplitude: 10, // The amplitude of the side-to-side gliding motion
      scaleVariation: 0.18, // The amount of random size variation during flight
      rotationVariation: 5, // The amount of random rotation variation during flight
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.94, // The friction that slows down the insect
      maxSpeed: 160, // The maximum movement speed
      acceleration: 0.6 // The acceleration rate
    },
    yellow_butterfly: {
      useSpriteSheet: false, // Whether to use a sprite sheet for animation (false for butterflies)
      wingFlapSpeed: 0.12, // The speed of the wing flapping animation
      wingFlapIntensity: 0.25, // The intensity or amplitude of the wing flap
      bodyFloatSpeed: 0.06, // The speed of the vertical floating motion
      bodyFloatIntensity: 7, // The intensity or amplitude of the vertical floating motion
      glideAmplitude: 8, // The amplitude of the side-to-side gliding motion
      scaleVariation: 0.15, // The amount of random size variation during flight
      rotationVariation: 4, // The amount of random rotation variation during flight
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.9, // The friction that slows down the insect
      maxSpeed: 240, // The maximum movement speed
      acceleration: 1.0 // The acceleration rate
    },
    pink_butterfly: {
      useSpriteSheet: false, // Whether to use a sprite sheet for animation (false for butterflies)
      wingFlapSpeed: 0.09, // The speed of the wing flapping animation
      wingFlapIntensity: 0.32, // The intensity or amplitude of the wing flap
      bodyFloatSpeed: 0.045, // The speed of the vertical floating motion
      bodyFloatIntensity: 9, // The intensity or amplitude of the vertical floating motion
      glideAmplitude: 11, // The amplitude of the side-to-side gliding motion
      scaleVariation: 0.22, // The amount of random size variation during flight
      rotationVariation: 5, // The amount of random rotation variation during flight
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.93, // The friction that slows down the insect
      maxSpeed: 180, // The maximum movement speed
      acceleration: 0.65 // The acceleration rate
    },
    
    // BEETLES - Realistic walking mechanics
    golden_beetle: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'beetle_sprite.png', // The filename of the sprite sheet image
      frameWidth: 120, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 3, // The number of frames horizontally in the sprite sheet
      framesY: 3, // The number of frames vertically in the sprite sheet
      totalFrames: 7, // The total number of frames in the sprite sheet
      walkCycleLength: 1.5, // The duration of a full walk cycle
      legPhases: [0, 0.5, 0.25, 0.75, 0.125, 0.625], // The timing phases for each of the 6 legs
      bodyRockAmplitude: 6, // The amplitude of the body's side-to-side rocking motion when walking
      stepHeight: 4, // The height of the leg lift during a step
      groundFriction: 0.8, // The friction between the legs and the ground
      bodyWeight: 1.2, // The perceived weight of the insect, affecting its movement
      centerOfMass: 0.6, // The center of mass, affecting balance
      legStrength: 0.8, // The strength of the leg push
      stabilityFactor: 0.7, // The stability of the insect when moving
      animationSpeed: 8, // The playback speed of the walking animation
      idleSpeed: 0, // The playback speed of the animation when idle (usually 0 for walking)
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.65, // The friction that slows down the insect
      maxSpeed: 1200, // The maximum movement speed
      acceleration: 3.0 // The acceleration rate
    },
    weavil: {
      useSpriteSheet: true, // Whether to use a sprite sheet for animation
      spriteFile: 'beetle_sprite.png', // The filename of the sprite sheet image
      frameWidth: 120, // The width of a single frame in the sprite sheet
      frameHeight: 120, // The height of a single frame in the sprite sheet
      framesX: 3, // The number of frames horizontally in the sprite sheet
      framesY: 3, // The number of frames vertically in the sprite sheet
      totalFrames: 7, // The total number of frames in the sprite sheet
      walkCycleLength: 1.8, // The duration of a full walk cycle
      legPhases: [0, 0.6, 0.3, 0.9, 0.15, 0.75], // The timing phases for each of the 6 legs
      bodyRockAmplitude: 4, // The amplitude of the body's side-to-side rocking motion when walking
      stepHeight: 3, // The height of the leg lift during a step
      groundFriction: 0.9, // The friction between the legs and the ground
      bodyWeight: 0.8, // The perceived weight of the insect, affecting its movement
      centerOfMass: 0.7, // The center of mass, affecting balance
      legStrength: 0.6, // The strength of the leg push
      stabilityFactor: 0.8, // The stability of the insect when moving
      animationSpeed: 6, // The playback speed of the walking animation
      idleSpeed: 0, // The playback speed of the animation when idle (usually 0 for walking)
      easing: 0.14, // The easing factor for smooth movement
      friction: 0.6, // The friction that slows down the insect
      maxSpeed: 800, // The maximum movement speed
      acceleration: 3.5 // The acceleration rate
    }
  };

  function generateConfig(insectName) {
    if (spriteConfigs[insectName]) {
      return spriteConfigs[insectName];
    }

    let baseType;
    if (insectName.includes('bee')) baseType = 'bee';
    else if (insectName.includes('butterfly')) baseType = 'butterfly';
    else if (insectName.includes('weavil')) baseType = 'weavil';
    else if (insectName.includes('beetle')) baseType = 'beetle';
    else return null;

    const baseConfig = baseSpriteConfigs[baseType];
    if (!baseConfig) return null;

    let newConfig = JSON.parse(JSON.stringify(baseConfig));

    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0;
      }
      return Math.abs(hash);
    }

    const seed = simpleHash(insectName);

    function seededRandom(seed) {
      let state = seed;
      return function() {
        state = (state * 9301 + 49297) % 233280;
        return state / 233280;
      };
    }

    const rand = seededRandom(seed);
    const randomize = (val, factor) => val * (1 + (rand() - 0.5) * factor);

    if (baseType === 'bee') {
      newConfig.wingBeatFreq = randomize(newConfig.wingBeatFreq, 0.2);
      newConfig.hoverJitter = randomize(newConfig.hoverJitter, 0.3);
      newConfig.maxSpeed = randomize(newConfig.maxSpeed, 0.2);
      newConfig.acceleration = randomize(newConfig.acceleration, 0.2);
    } else if (baseType === 'butterfly') {
      newConfig.wingFlapSpeed = randomize(newConfig.wingFlapSpeed, 0.3);
      newConfig.glideAmplitude = randomize(newConfig.glideAmplitude, 0.4);
      newConfig.maxSpeed = randomize(newConfig.maxSpeed, 0.3);
    } else if (baseType === 'beetle' || baseType === 'weavil') {
      newConfig.bodyRockAmplitude = randomize(newConfig.bodyRockAmplitude, 0.2);
      newConfig.maxSpeed = randomize(newConfig.maxSpeed, 0.1);
      newConfig.acceleration = randomize(newConfig.acceleration, 0.1);
    }

    spriteConfigs[insectName] = newConfig;
    return newConfig;
  }

  // Initialize
  $(document).ready(function () {
    var idleInterval = setInterval(timerIncrement, 1000);
    $(this).mousemove(function (e) { idleTime = 0; });
    $(this).keypress(function (e) { idleTime = 0; });
  });

  function timerIncrement() {
    idleTime = idleTime + 1;
    if (idleTime == 60) {
      socket.emit('inactive')
    }
  }

  function determineInsectType(imagePath) {
    const filename = imagePath.split('/').pop().toLowerCase();
    const nameOnly = filename.substring(0, filename.lastIndexOf('.'));
    const parts = nameOnly.split('-');
    
    // Standardized format: "name-type.png" or "type.png"
    if (parts.length > 0) {
      const type = parts[parts.length - 1];
      if (['bee', 'butterfly', 'beetle', 'weavil'].includes(type)) {
        return nameOnly;
      }
    }
    
    // New, automated approach based on "name-type.png" format
    const match = filename.match(/^(.*?)-(bee|butterfly|beetle|weavil)\.png$/);
    if (match) {
      return `${match[1]}-${match[2]}`; // e.g., "yellow-bee"
    }
    
    // Fallback for existing hardcoded names
    var path = imagePath.toLowerCase();
    if (path.includes('yellow') && (path.includes('bee') || path.includes('bumble'))) return 'yellow_bee';
    if (path.includes('purple') && (path.includes('bee') || path.includes('bumble'))) return 'purple_bee';
    if (path.includes('blue') && (path.includes('bee') || path.includes('bumble'))) return 'blue_bee';
    if (path.includes('red') && path.includes('butterfly')) return 'red_butterfly';
    if (path.includes('purple') && path.includes('butterfly')) return 'purple_butterfly';
    if (path.includes('yellow') && path.includes('butterfly')) return 'yellow_butterfly';
    if (path.includes('pink') && path.includes('butterfly')) return 'pink_butterfly';
    if (path.includes('weavil') || path.includes('weevil')) return 'weavil';
    if (path.includes('beetle') || path.includes('golden') || path.includes('scarab')) return 'golden_beetle';
    
    // General fallbacks
    if (path.includes('bee')) return 'yellow_bee';
    if (path.includes('butterfly')) return 'red_butterfly';
    if (path.includes('beetle')) return 'golden_beetle';
    
    return 'yellow_bee'; // Default
  }

  function loadSpriteSheet(config, callback) {
    if (!config.useSpriteSheet) {
      callback(true);
      return;
    }

    var spriteFileName = config.spriteFile.includes('/') ? config.spriteFile.split('/').pop() : config.spriteFile;
    
    var possiblePaths = [
      `/static/images/${spriteFileName}`,
      `/images/${spriteFileName}`,
      `../public/images/${spriteFileName}`,
      `./public/images/${spriteFileName}`
    ];

    function tryPath(pathIndex) {
      if (pathIndex >= possiblePaths.length) {
        console.error('Failed to load sprite sheet for', config.spriteFile);
        callback(false);
        return;
      }

      var path = possiblePaths[pathIndex];
      console.log(`Loading sprite: ${path}`);

      loadImage(path,
        function(img) {
          console.log(`✓ Sprite loaded: ${path}`);
          spriteSheet = img;
          extractFrames(config);
          callback(true);
        },
        function(err) {
          console.log(`✗ Failed: ${path}`);
          tryPath(pathIndex + 1);
        }
      );
    }

    tryPath(0);
  }

  function extractFrames(config) {
    spriteFrames = [];
    for (let i = 0; i < config.totalFrames; i++) {
      let frameX = (i % config.framesX) * config.frameWidth;
      let frameY = Math.floor(i / config.framesX) * config.frameHeight;
      let frameGraphics = createGraphics(config.frameWidth, config.frameHeight);
      // Ensure transparency: clear the buffer
      frameGraphics.clear();
      frameGraphics.copy(spriteSheet, frameX, frameY, config.frameWidth, config.frameHeight, 0, 0, config.frameWidth, config.frameHeight);
      spriteFrames[i] = frameGraphics;
    }
    currentFrame = 0;
  }

  function updateRealisticBehavior() {
    var config = spriteConfigs[insectType];
    if (!config) return;
    var timeScale = deltaTime / 16.67;
    stateTimer += timeScale;
    animationFrame += timeScale;
    // Calculate acceleration for realistic physics
    acceleration.x = velocityX - lastVelocityX;
    acceleration.y = velocityY - lastVelocityY;
    lastVelocityX = velocityX;
    lastVelocityY = velocityY;
    if (config.useSpriteSheet && insectType.includes('bee')) {
      updateBeePhysics(config, timeScale);
    } else if (config.useSpriteSheet && (insectType.includes('beetle') || insectType.includes('weavil'))) {
      updateBeetlePhysics(config, timeScale);
    }
  }

  function updateBeePhysics(config, timeScale) {
    // Realistic bee hovering with micro-instabilities
    wingPhase += config.wingBeatFreq * 0.1 * timeScale;
    
    // Wing beat creates lift and slight instability
    var liftForce = sin(wingPhase) * config.liftCoefficient;
    var wingDownstroke = sin(wingPhase) > 0;
    
    // Hovering instability (bees can't hover perfectly)
    hoverOffset.x += (noise(animationFrame * 0.01) - 0.5) * config.hoverJitter * timeScale;
    hoverOffset.y += (noise(animationFrame * 0.01 + 100) - 0.5) * config.hoverJitter * timeScale;
    
    // Dampen hover offset
    hoverOffset.x *= 0.95;
    hoverOffset.y *= 0.95;
    
    // Body tilt based on acceleration (like real flight)
    var targetTilt = atan2(acceleration.y, acceleration.x) * 0.3;
    bodyTilt = lerp(bodyTilt, targetTilt, 0.1);
    bodyTilt = constrain(bodyTilt, -radians(config.maxTilt), radians(config.maxTilt));

    // Antennae movement
    antennaeAngle = sin(animationFrame * 0.2) * 0.3 + bodyTilt * 0.5;

    // Sprite animation sync with wing beats
    if (wingDownstroke !== (currentFrame === 1)) {
      currentFrame = wingDownstroke ? 1 : 0;
    }
  }

  function updateBeetlePhysics(config, timeScale) {
    if (isMoving) {
      // REALISTIC BEETLE WALKING - Clean and smooth
      
      var realWalkSpeed = movementSpeed * 0.12 * timeScale;
      walkPhase += realWalkSpeed;
      
      var totalCycleTime = config.walkCycleLength * 60;
      var cycleProgress = (walkPhase % totalCycleTime) / totalCycleTime;
      
      var rawFrameIndex = cycleProgress * config.totalFrames;
      var frameIndex = Math.floor(rawFrameIndex);
      
      currentFrame = constrain(frameIndex, 0, config.totalFrames - 1);
      
      // Get leg configuration for body response
      var legConfiguration = getLegConfiguration(currentFrame, 0);
      
      // BODY RESPONDS TO LEG POSITIONS
      bodyWeight = legConfiguration.weight;
      var legSupport = legConfiguration.support;
      var legPush = legConfiguration.push;
      var stability = legConfiguration.stability;
      
      // VERTICAL MOVEMENT - Body height based on leg extension
      var legExtension = legConfiguration.extension;
      var bodyHeight = -legExtension * config.stepHeight;
      
      // FORWARD PUSH - When legs push backward, body moves forward
      var forwardThrust = legConfiguration.thrust;
      var bodyPush = forwardThrust * movementSpeed * 0.5;
      
      // SIDE BALANCE - Body tips based on which legs are up/down
      var legBalance = legConfiguration.balance;
      var sideTilt = legBalance * config.bodyRockAmplitude;
      
      // TILT FROM LEG POSITIONS
      bodyTilt = radians(legConfiguration.tilt) + (forwardThrust * 0.1);
      
      // GROUND CONTACT
      groundContact = legConfiguration.grounded;
      
      // APPLY PHYSICS
      hoverOffset.x = sideTilt + bodyPush;
      hoverOffset.y = bodyHeight;
      
      // MOMENTUM FROM LEG PUSHES
      if (forwardThrust > 0.5) {
        momentumX += cos(angle1) * forwardThrust * 0.3;
        momentumY += sin(angle1) * forwardThrust * 0.3;
      }
      momentumX *= 0.95;
      momentumY *= 0.95;
      hoverOffset.x += momentumX;
      hoverOffset.y += momentumY;
      
      // ANTENNAE RESPOND TO WALKING
      antennaeAngle = sin(walkPhase * 0.5) * 0.4 + cos(rawFrameIndex * 0.8) * 0.2;
      
    } else {
      // RESTING BEHAVIOR
      walkPhase *= 0.96;
      bodyWeight = 0.95;
      bodyTilt *= 0.9;
      currentFrame = 0;
      
      // SETTLED POSITION
      hoverOffset.y = bodyWeight * 2;
      hoverOffset.x *= 0.9;
      
      // SUBTLE BREATHING
      var breathe = sin(animationFrame * 0.04) * 0.4;
      hoverOffset.y += breathe;
      
      // ANTENNAE STILL ACTIVE
      antennaeAngle = sin(animationFrame * 0.06) * 0.15;
      
      groundContact = true;
      momentumX *= 0.9;
      momentumY *= 0.9;
    }
    
    // CONSTRAIN LIMITS
    bodyTilt = constrain(bodyTilt, -radians(30), radians(30));
    antennaeAngle = constrain(antennaeAngle, -radians(50), radians(50));
    hoverOffset.x = constrain(hoverOffset.x, -10, 10);
    hoverOffset.y = constrain(hoverOffset.y, -6, 4);
  }

  // LEG CONFIGURATION - Clean and effective
  function getLegConfiguration(frameIndex, progress) {
    var configs = [
      // Frame 0: Rest position - all legs down
      {
        weight: 0.9, support: 1.0, push: 0.0, stability: 1.0, extension: 0.1,
        thrust: 0.0, balance: 0.0, tilt: 0, grounded: true,
        legs: {
          L1: {down: true, forward: 0.0, height: 0.0},
          L2: {down: true, forward: 0.0, height: 0.0},
          L3: {down: true, forward: 0.0, height: 0.0},
          R1: {down: true, forward: 0.0, height: 0.0},
          R2: {down: true, forward: 0.0, height: 0.0},
          R3: {down: true, forward: 0.0, height: 0.0}
        }
      },
      
      // Frame 1: Right tripod (R1,L2,R3) starts lifting
      {
        weight: 0.7, support: 0.5, push: 0.2, stability: 0.6, extension: 0.4,
        thrust: 0.1, balance: -0.3, tilt: 2, grounded: false,
        legs: {
          L1: {down: true, forward: 0.1, height: 0.0},
          L2: {down: false, forward: -0.2, height: 0.3},
          L3: {down: true, forward: 0.1, height: 0.0},
          R1: {down: false, forward: -0.2, height: 0.3},
          R2: {down: true, forward: 0.1, height: 0.0},
          R3: {down: false, forward: -0.2, height: 0.3}
        }
      },
      
      // Frame 2: Right tripod high and moving forward
      {
        weight: 0.6, support: 0.5, push: 0.4, stability: 0.4, extension: 0.8,
        thrust: 0.3, balance: -0.5, tilt: 5, grounded: false,
        legs: {
          L1: {down: true, forward: 0.3, height: 0.0},
          L2: {down: false, forward: 0.2, height: 0.8},
          L3: {down: true, forward: 0.3, height: 0.0},
          R1: {down: false, forward: 0.2, height: 0.8},
          R2: {down: true, forward: 0.3, height: 0.0},
          R3: {down: false, forward: 0.2, height: 0.8}
        }
      },
      
      // Frame 3: Right tripod coming down, left tripod preparing
      {
        weight: 0.8, support: 0.7, push: 0.6, stability: 0.5, extension: 0.5,
        thrust: 0.5, balance: 0.0, tilt: 3, grounded: true,
        legs: {
          L1: {down: false, forward: 0.0, height: 0.2},
          L2: {down: true, forward: 0.4, height: 0.0},
          L3: {down: false, forward: 0.0, height: 0.2},
          R1: {down: true, forward: 0.4, height: 0.0},
          R2: {down: false, forward: 0.0, height: 0.2},
          R3: {down: true, forward: 0.4, height: 0.0}
        }
      },
      
      // Frame 4: Left tripod (L1,R2,L3) lifting
      {
        weight: 0.7, support: 0.5, push: 0.3, stability: 0.6, extension: 0.6,
        thrust: 0.4, balance: 0.3, tilt: 4, grounded: false,
        legs: {
          L1: {down: false, forward: -0.2, height: 0.4},
          L2: {down: true, forward: 0.2, height: 0.0},
          L3: {down: false, forward: -0.2, height: 0.4},
          R1: {down: true, forward: 0.2, height: 0.0},
          R2: {down: false, forward: -0.2, height: 0.4},
          R3: {down: true, forward: 0.2, height: 0.0}
        }
      },
      
      // Frame 5: Left tripod high and forward
      {
        weight: 0.6, support: 0.5, push: 0.5, stability: 0.4, extension: 0.9,
        thrust: 0.6, balance: 0.5, tilt: 6, grounded: false,
        legs: {
          L1: {down: false, forward: 0.3, height: 0.9},
          L2: {down: true, forward: 0.4, height: 0.0},
          L3: {down: false, forward: 0.3, height: 0.9},
          R1: {down: true, forward: 0.4, height: 0.0},
          R2: {down: false, forward: 0.3, height: 0.9},
          R3: {down: true, forward: 0.4, height: 0.0}
        }
      },
      
      // Frame 6: Power stroke - all legs down, maximum push
      {
        weight: 1.0, support: 1.0, push: 0.8, stability: 0.8, extension: 0.2,
        thrust: 0.8, balance: 0.0, tilt: 8, grounded: true,
        legs: {
          L1: {down: true, forward: 0.5, height: 0.0},
          L2: {down: true, forward: 0.3, height: 0.0},
          L3: {down: true, forward: 0.5, height: 0.0},
          R1: {down: true, forward: 0.5, height: 0.0},
          R2: {down: true, forward: 0.3, height: 0.0},
          R3: {down: true, forward: 0.5, height: 0.0}
        }
      }
    ];
    
    return configs[frameIndex] || configs[0];
  }

  // DRAW VISIBLE LEG POSITIONS WITH 3D EFFECTS
  function drawBeetleLegs(currentX, currentY, angle, legConfig) {
    if (!insectType.includes('beetle') && !insectType.includes('weavil')) return;
    
    push();
    translate(currentX, currentY);
    rotate(angle + radians(90));
    
    // 3D perspective settings
    var groundLevel = 40; // How far below beetle is ground
    var perspectiveFactor = 0.7; // Perspective scaling
    var bodyHeight = 8; // Beetle body height above ground
    
    // Beetle body dimensions for leg positioning
    var bodyWidth = 25;
    var bodyLength = 35;
    
    // Leg positions relative to beetle body with 3D Z-depth
    var legPositions = [
      {name: 'L1', x: -bodyWidth*0.8, y: -bodyLength*0.6, z: 0.8, side: 'left'},   // Left front (closer)
      {name: 'L2', x: -bodyWidth*0.9, y: 0, z: 1.0, side: 'left'},                 // Left middle (closest)
      {name: 'L3', x: -bodyWidth*0.8, y: bodyLength*0.6, z: 0.6, side: 'left'},    // Left rear (farther)
      {name: 'R1', x: bodyWidth*0.8, y: -bodyLength*0.6, z: 0.2, side: 'right'},   // Right front (far)
      {name: 'R2', x: bodyWidth*0.9, y: 0, z: 0.0, side: 'right'},                 // Right middle (farthest)
      {name: 'R3', x: bodyWidth*0.8, y: bodyLength*0.6, z: 0.4, side: 'right'}     // Right rear (medium far)
    ];
    
    // Sort legs by Z-depth for proper rendering order (back to front)
    var sortedLegs = legPositions.slice().sort((a, b) => a.z - b.z);
    
    // Draw 3D ground plane first
    if (isMoving) {
      drawGroundPlane(groundLevel, bodyWidth * 3);
    }
    
    // Draw 3D leg shadows on ground plane
    sortedLegs.forEach(function(pos) {
      var leg = legConfig.legs[pos.name];
      if (!leg) return;
      
      drawLeg3DShadow(pos, leg, groundLevel, bodyHeight, perspectiveFactor);
    });
    
    // Draw each leg with 3D effects (back to front)
    sortedLegs.forEach(function(pos) {
      var leg = legConfig.legs[pos.name];
      if (!leg) return;
      
      drawLeg3D(pos, leg, groundLevel, bodyHeight, perspectiveFactor);
    });
    
    // Draw 3D tripod group connections
    if (isMoving) {
      draw3DTripodConnections(legPositions, legConfig, perspectiveFactor);
    }
    
    // 3D Frame indicator
    if (isMoving) {
      push();
      fill(255, 255, 0, 200);
      textAlign(CENTER, CENTER);
      textSize(14);
      // 3D text effect
      fill(0, 0, 0, 100);
      text('F' + currentFrame, 1, -49); // Shadow
      fill(255, 255, 0, 255);
      text('F' + currentFrame, 0, -50); // Main text
      pop();
    }
    
    pop();
  }

  // Draw 3D ground plane with good perspective (simplified)
  function drawGroundPlane(groundLevel, size) {
    push();
    translate(0, groundLevel);
    
    // Ground grid with perspective (HIDDEN)
    stroke(100, 100, 100, 0); // fully transparent
    strokeWeight(1);
    var gridSize = 10;
    var gridLines = Math.floor(size / gridSize);
    
    for (let i = -gridLines; i <= gridLines; i++) {
      var lineAlpha = 0; // Hide all lines
      if (lineAlpha > 0) {
        stroke(100, 100, 100, lineAlpha);
        line(i * gridSize, -size, i * gridSize, size);
        line(-size, i * gridSize, size, i * gridSize);
      }
    }
    
    // Ground surface highlight (HIDDEN)
    fill(120, 120, 120, 0);
    noStroke();
    ellipse(0, 0, size * 1.5, size * 0.8); // Oval ground patch (invisible)
    
    // Simple ground texture (HIDDEN)
    for (let i = 0; i < 20; i++) {
      var texX = random(-size * 0.8, size * 0.8);
      var texY = random(-size * 0.6, size * 0.6);
      var texAlpha = 0;
      if (texAlpha > 0) {
        fill(80, 60, 40, texAlpha);
        circle(texX, texY, random(2, 4));
      }
    }
    
    pop();
  }

  // Draw 3D leg shadow on ground
  function drawLeg3DShadow(pos, leg, groundLevel, bodyHeight, perspectiveFactor) {
    if (!leg.down && leg.height > 0.3) return; // No shadow for high lifted legs
    
    push();
    
    // Calculate 3D positions
    var legStartX = pos.x;
    var legStartY = pos.y;
    var legStartZ = bodyHeight;
    
    var legLength = 15;
    var legEndX = legStartX + (pos.side === 'left' ? -1 : 1) * legLength;
    var legEndY = legStartY + leg.forward * 8;
    var legEndZ = leg.down ? 0 : (-leg.height * 12 + bodyHeight);
    
    // Project shadow onto ground plane
    var shadowStartX = legStartX;
    var shadowStartY = legStartY + groundLevel;
    var shadowEndX = legEndX;
    var shadowEndY = legEndY + groundLevel;
    
    // Shadow opacity based on leg height
    var shadowAlpha = leg.down ? 150 : (150 * (1 - leg.height));
    
    stroke(0, 0, 0, shadowAlpha);
    strokeWeight(6);
    line(shadowStartX, shadowStartY, shadowEndX, shadowEndY);
    
    // Shadow tip
    fill(0, 0, 0, shadowAlpha * 0.8);
    noStroke();
    ellipse(shadowEndX, shadowEndY, 8, 4); // Oval shadow tip
    
    pop();
  }

  // Draw individual leg with GOOD 3D effects (simplified)
  function drawLeg3D(pos, leg, groundLevel, bodyHeight, perspectiveFactor) {
    push();
    
    // Calculate 3D positions
    var legStartX = pos.x;
    var legStartY = pos.y;
    var legStartZ = bodyHeight;
    
    var legLength = 15;
    var legEndX = legStartX + (pos.side === 'left' ? -1 : 1) * legLength;
    var legEndY = legStartY;
    var legEndZ = bodyHeight;
    
    // Apply leg movement in 3D space
    legEndX += leg.forward * 8; // Forward/back movement
    
    if (leg.down) {
      legEndZ = 0; // On ground
    } else {
      // 3D ARC MOTION when leg is lifted
      var liftHeight = leg.height * 15;
      var arcProgress = leg.forward + 0.5; // Convert forward position to arc progress
      
      // Create natural leg lifting arc
      legEndZ = bodyHeight + sin(arcProgress * PI) * liftHeight;
      legEndY += cos(arcProgress * PI) * 3; // Slight forward curve
    }
    
    // Apply 3D perspective scaling based on Z-depth
    var depthScale = perspectiveFactor + (1 - perspectiveFactor) * pos.z;
    var legThickness = leg.down ? 4 : 3;
    legThickness *= depthScale;
    
    // Color with depth-based saturation
    var isLifted = !leg.down;
    var baseColor = isLifted ? color(255, 179, 71) : color(139, 69, 19);
    var depthDarkening = 255 * (0.7 + 0.3 * pos.z); // Farther = darker
    var legColor = lerpColor(color(0), baseColor, depthDarkening / 255);
    
    // Draw 3D leg segments (simple but effective)
    var segmentCount = 3; // Break leg into segments for more 3D effect
    for (let seg = 0; seg < segmentCount; seg++) {
      var segmentProgress = seg / (segmentCount - 1);
      var nextProgress = (seg + 1) / (segmentCount - 1);
      
      var segStartX = lerp(legStartX, legEndX, segmentProgress);
      var segStartY = lerp(legStartY, legEndY, segmentProgress);
      var segStartZ = lerp(legStartZ, legEndZ, segmentProgress);
      
      var segEndX = lerp(legStartX, legEndX, nextProgress);
      var segEndY = lerp(legStartY, legEndY, nextProgress);
      var segEndZ = lerp(legStartZ, legEndZ, nextProgress);
      
      // Convert 3D to 2D with perspective
      var start2DY = segStartY - segStartZ;
      var end2DY = segEndY - segEndZ;
      
      // Apply perspective scaling
      var startScale = perspectiveFactor + (1 - perspectiveFactor) * (segStartZ / 20 + 0.5);
      var endScale = perspectiveFactor + (1 - perspectiveFactor) * (segEndZ / 20 + 0.5);
      
      stroke(legColor);
      strokeWeight(legThickness * ((startScale + endScale) / 2));
      line(segStartX, start2DY, segEndX, end2DY);
      
      // Simple joint dots
      if (seg < segmentCount - 1) {
        fill(red(legColor) * 0.8, green(legColor) * 0.8, blue(legColor) * 0.8);
        noStroke();
        var jointSize = 3 * ((startScale + endScale) / 2);
        ellipse(segEndX, end2DY, jointSize, jointSize);
      }
    }
    
    // Draw 3D leg tip with depth
    var tipScale = perspectiveFactor + (1 - perspectiveFactor) * (legEndZ / 20 + 0.5);
    var tip2DY = legEndY - legEndZ;
    
    if (leg.down) {
      // Grounded leg tip with 3D ground contact
      fill(101, 67, 33);
      noStroke();
      ellipse(legEndX, tip2DY, 6 * tipScale, 4 * tipScale); // Flattened by perspective
      
      // 3D ground contact ring
      stroke(0, 255, 0, 180);
      strokeWeight(2);
      noFill();
      ellipse(legEndX, tip2DY, 10 * tipScale, 6 * tipScale);
      
      // Ground pressure indicator
      fill(0, 255, 0, 60);
      noStroke();
      ellipse(legEndX, tip2DY, 15 * tipScale, 8 * tipScale);
      
    } else {
      // Lifted leg tip with 3D motion blur
      fill(255, 179, 71, 200);
      noStroke();
      ellipse(legEndX, tip2DY, 4 * tipScale, 4 * tipScale);
      
      // 3D motion trail
      for (let i = 1; i <= 4; i++) {
        var trailAlpha = 200 - i * 40;
        var trailScale = tipScale * (1 - i * 0.1);
        fill(255, 179, 71, trailAlpha);
        
        var trailX = legEndX - leg.forward * i * 2;
        var trailZ = legEndZ + i * 2;
        var trail2DY = legEndY - trailZ;
        
        ellipse(trailX, trail2DY, 4 * trailScale, 4 * trailScale);
      }
      
      // 3D movement vector
      if (isMoving) {
        stroke(255, 100, 100, 150);
        strokeWeight(2 * tipScale);
        var vectorEndX = legEndX + leg.forward * 15;
        var vector2DY = tip2DY - 5;
        line(legEndX, tip2DY, vectorEndX, vector2DY);
        
        // 3D arrowhead
        fill(255, 100, 100, 150);
        noStroke();
        var arrowSize = 4 * tipScale;
        triangle(vectorEndX, vector2DY,
                vectorEndX - arrowSize, vector2DY - arrowSize * 0.5,
                vectorEndX - arrowSize, vector2DY + arrowSize * 0.5);
      }
    }
    
    pop();
  }

  // Draw 3D tripod connections
  function draw3DTripodConnections(legPositions, legConfig, perspectiveFactor) {
    // Tripod 1: R1, L2, R3
    var tripod1Active = (currentFrame === 1 || currentFrame === 2);
    if (tripod1Active) {
      stroke(255, 0, 0, 120);
      strokeWeight(2);
      noFill();
      
      var r1 = legPositions.find(p => p.name === 'R1');
      var l2 = legPositions.find(p => p.name === 'L2');
      var r3 = legPositions.find(p => p.name === 'R3');
      
      // 3D connection lines with depth
      var r1Scale = perspectiveFactor + (1 - perspectiveFactor) * r1.z;
      var l2Scale = perspectiveFactor + (1 - perspectiveFactor) * l2.z;
      var r3Scale = perspectiveFactor + (1 - perspectiveFactor) * r3.z;
      
      line(r1.x, r1.y - 5, l2.x, l2.y - 8); // Perspective offset
      line(l2.x, l2.y - 8, r3.x, r3.y - 3);
    }
    
    // Tripod 2: L1, R2, L3
    var tripod2Active = (currentFrame === 4 || currentFrame === 5);
    if (tripod2Active) {
      stroke(0, 0, 255, 120);
      strokeWeight(2);
      noFill();
      
      var l1 = legPositions.find(p => p.name === 'L1');
      var r2 = legPositions.find(p => p.name === 'R2');
      var l3 = legPositions.find(p => p.name === 'L3');
      
      line(l1.x, l1.y - 6, r2.x, r2.y - 2); // 3D perspective
      line(r2.x, r2.y - 2, l3.x, l3.y - 4);
    }
  }

  function setup() {
    canvas = createCanvas(windowWidth, windowHeight, [P2D]);
    canvas.style("display", "block")
    background(0);
    targetX = windowWidth / 2;
    targetY = windowHeight / 2;
    smoothTargetX = targetX;
    smoothTargetY = targetY;
    x = targetX;
    y = targetY;
    
    socket = io.connect();
    socket.on('connect', () => socket.emit('client'))
    socket.on('image', function(d) {
      insectType = determineInsectType(d.image);
      console.log('Detected insect type:', insectType);
      
      var config = generateConfig(insectType);
      if (!config) {
        console.warn('Could not generate a config for', insectType, '- using fallback.');
        insectType = 'yellow_bee';
        config = spriteConfigs[insectType];
      }

      loadImage(d.image, function(originalImg) {
        img = originalImg;
        imgUrl = d.image;
        
        loadSpriteSheet(config, function(success) {
          targetX = windowWidth / 2;
          targetY = windowHeight / 2;
          smoothTargetX = targetX;
          smoothTargetY = targetY;
          x = targetX;
          y = targetY;
          imgLoaded = true;
          console.log(success ? '✓ Ready for realistic animation' : '⚠ Using fallback');
          loop();
        });
      });
    })
    noLoop();
  }

  function smoothLerp(current, target, factor) {
    return current + (target - current) * factor;
  }

  function updateSmoothMovement() {
    var config = spriteConfigs[insectType] || generateConfig(insectType) || spriteConfigs.yellow_bee;
    var timeScale = deltaTime / 16.67;
    var followDistance = 50;
    var dx = targetX - x;
    var dy = targetY - y;
    var distanceToTarget = sqrt(dx * dx + dy * dy);
    if (distanceToTarget < followDistance) {
      var angle = atan2(dy, dx);
      var adjustedTargetX = targetX - cos(angle) * (followDistance - distanceToTarget);
      var adjustedTargetY = targetY - sin(angle) * (followDistance - distanceToTarget);
      smoothTargetX = smoothLerp(smoothTargetX, adjustedTargetX, 0.08 * timeScale);
      smoothTargetY = smoothLerp(smoothTargetY, adjustedTargetY, 0.08 * timeScale);
    } else {
      smoothTargetX = smoothLerp(smoothTargetX, targetX, 0.12 * timeScale);
      smoothTargetY = smoothLerp(smoothTargetY, targetY, 0.12 * timeScale);
    }
    dx = smoothTargetX - x;
    dy = smoothTargetY - y;
    var distance = sqrt(dx * dx + dy * dy);
    if (distance > 1) {
      dx /= distance;
      dy /= distance;
      var accelerationScale = min(distance / 100, 1);
      velocityX += dx * config.acceleration * accelerationScale * timeScale;
      velocityY += dy * config.acceleration * accelerationScale * timeScale;
      var speed = sqrt(velocityX * velocityX + velocityY * velocityY);
      if (speed > config.maxSpeed) {
        velocityX = (velocityX / speed) * config.maxSpeed;
        velocityY = (velocityY / speed) * config.maxSpeed;
      }
    }
    velocityX *= Math.pow(config.friction, timeScale);
    velocityY *= Math.pow(config.friction, timeScale);
    x += velocityX * timeScale;
    y += velocityY * timeScale;
    var desiredAngle = atan2(velocityY, velocityX);
    var angleDiff = desiredAngle - angle1;
    if (angleDiff > PI) angleDiff -= TWO_PI;
    if (angleDiff < -PI) angleDiff += TWO_PI;
    var angleEasing = map(movementSpeed, 0, config.maxSpeed, 0.05, 0.15) * timeScale;
    angle1 += angleDiff * angleEasing;
  }

  function calculateNaturalMovement() {
    movementSpeed = sqrt(velocityX * velocityX + velocityY * velocityY);
    isMoving = movementSpeed > 0.5;

    updateRealisticBehavior();

    var config = spriteConfigs[insectType] || generateConfig(insectType) || spriteConfigs.yellow_bee;

    // For butterflies, use mathematical animation
    if (!config.useSpriteSheet) {
      var organicTransforms = {
        translateX: 0,
        translateY: 0,
        scaleX: 1,
        scaleY: 1,
        rotation: 0
      };

      var wingFlap = sin(animationFrame * config.wingFlapSpeed) * config.wingFlapIntensity;
      var bodyFloat = sin(animationFrame * config.bodyFloatSpeed) * config.bodyFloatIntensity;
      var glideEffect = sin(animationFrame * 0.03) * config.glideAmplitude;
      
      organicTransforms.scaleX = 1 + wingFlap + sin(animationFrame * 0.08) * config.scaleVariation;
      organicTransforms.scaleY = 1; // Y axis scale is constant for more natural look
      organicTransforms.translateY = bodyFloat + glideEffect;
      organicTransforms.translateX = sin(animationFrame * 0.04) * 3;
      organicTransforms.rotation = sin(animationFrame * 0.06) * radians(config.rotationVariation);
      
      if (isMoving) {
        organicTransforms.scaleX *= (1 + movementSpeed * 0.12);
        organicTransforms.translateY *= (1 + movementSpeed * 0.08);
      } else {
        organicTransforms.scaleX *= 0.6;
        organicTransforms.translateY *= 0.8;
      }

      return organicTransforms;
    }

    // For sprite-based insects, realistic transforms
    var organicTransforms = {
      translateX: hoverOffset.x,
      translateY: hoverOffset.y,
      scaleX: 1,
      scaleY: 1,
      rotation: bodyTilt
    };

    // ENHANCED BEETLE/WALKING INSECT PHYSICS - Synced to actual leg positions
    if (insectType.includes('beetle') || insectType.includes('weavil')) {
      var config = spriteConfigs[insectType] || generateConfig(insectType) || spriteConfigs.golden_beetle;
      
      // Get current leg configuration from sprite analysis
      var legConfig = getLegConfiguration(currentFrame, 0);
      
      // BODY WEIGHT COMPRESSION - Based on actual leg support
      var weightEffect = legConfig.weight * 3;
      organicTransforms.translateY += weightEffect;
      organicTransforms.scaleY = 1 - (legConfig.weight * 0.12);
      
      // LEG PUSH PHYSICS - When legs actually push in sprite
      if (legConfig.push > 0.3) {
        var pushForceX = cos(angle1) * legConfig.thrust * 2;
        var pushForceY = -legConfig.extension * config.stepHeight * 0.5;
        organicTransforms.translateX += pushForceX;
        organicTransforms.translateY += pushForceY;
      }
      
      // BALANCE BASED ON ACTUAL LEG POSITIONS
      var balanceShift = legConfig.balance * config.bodyRockAmplitude;
      organicTransforms.translateX += balanceShift;
      
      // STABILITY EFFECTS - When fewer legs down, more unstable
      if (legConfig.stability < 0.7) {
        var instability = (1 - legConfig.stability) * movementSpeed * 0.8;
        organicTransforms.translateX += sin(animationFrame * 0.3) * instability;
        organicTransforms.translateY += cos(animationFrame * 0.25) * instability * 0.5;
      }
      
      // GROUND CONTACT COMPRESSION
      if (legConfig.grounded && isMoving) {
        // When legs hit ground, body compresses
        var impactCompression = legConfig.support * 0.08;
        organicTransforms.scaleY *= (1 - impactCompression);
        organicTransforms.translateY += impactCompression * 3;
      }
      
      // FORWARD MOMENTUM FROM LEG THRUST
      if (legConfig.thrust > 0.4) {
        var thrustMomentum = legConfig.thrust * movementSpeed * 0.4;
        organicTransforms.translateX += cos(angle1) * thrustMomentum;
        organicTransforms.translateY -= sin(abs(angle1)) * thrustMomentum * 0.3; // Slight lift
      }
      
      // BODY TILT FROM ACTUAL LEG CONFIGURATION
      var configTilt = radians(legConfig.tilt * config.bodyWeight);
      organicTransforms.rotation += configTilt;
      
      // LEG EXTENSION EFFECTS - Body height varies with leg positions
      var legHeight = (1 - legConfig.extension) * 2;
      organicTransforms.translateY += legHeight;
      
      // REALISTIC WALKING STRUGGLE - Harder to walk when legs are transitioning
      if (legConfig.stability < 0.6 && isMoving) {
        var struggle = noise(walkPhase * 0.15) * (1 - legConfig.stability) * 1.5;
        organicTransforms.translateX += struggle;
        organicTransforms.rotation += struggle * 0.1;
      }
      
    } else if (insectType.includes('bee')) {
      // Keep bee hover effects
      organicTransforms.translateX += sin(animationFrame * 0.15) * 0.8;
      organicTransforms.translateY += cos(animationFrame * 0.12) * 0.6;
    }

    return organicTransforms;
  }

  function getCurrentFrame() {
    var config = spriteConfigs[insectType] || generateConfig(insectType) || spriteConfigs.yellow_bee;
    if (config && config.useSpriteSheet && spriteFrames.length > 0) {
      return spriteFrames[currentFrame];
    }
    return null;
  }

  function draw() {
    var now = performance.now();
    if (lastFrameTime === null) lastFrameTime = now;
    deltaTime = now - lastFrameTime;
    lastFrameTime = now;
    // Cap deltaTime to avoid huge jumps
    if (deltaTime > 100) deltaTime = 100;

    if (imgLoaded) {
      updateSmoothMovement();
      // Animate sprite frames for sprite-based insects
      var config = spriteConfigs[insectType] || generateConfig(insectType) || spriteConfigs.yellow_bee;
      if (config && config.useSpriteSheet && spriteFrames.length > 0) {
        // Advance frame based on animation speed
        frameCounter += deltaTime / 16.67;
        var speed = isMoving ? config.animationSpeed : config.idleSpeed;
        if (frameCounter >= (60 / speed)) {
          // Beetle walk cycle is driven by physics, not a simple timer
          if (!insectType.includes('beetle') && !insectType.includes('weavil')) {
            currentFrame = (currentFrame + 1) % config.totalFrames;
          }
          frameCounter = 0;
        }
      }
      insect(x, y);
    }
  }

  function mouseMoved() {
    var data = { x: mouseX, y: mouseY }
    socket.emit('mouse', data);
    targetX = data.x;
    targetY = data.y;
  }

  function mouseDragged() { mouseMoved(); }

  function touchMoved() {
    if (touches.length > 0) {
      var data = { x: touches[0].x, y: touches[0].y }
      socket.emit('mouse', data);
      targetX = data.x;
      targetY = data.y;
    }
    return false;
  }

  function insect(currentX, currentY) {
    stroke(255,0,0);
    fill(0,0,0);
    imageMode(CENTER);
    background(0);
    
    segment(currentX, currentY, angle1);

    function segment(varx, vary, vara) {
      push();
      
      var transforms = calculateNaturalMovement();
      
      // Apply base position and rotation
      translate(varx, vary);
      rotate(vara + radians(90));
      
      // Apply natural movement transformations
      translate(transforms.translateX, transforms.translateY);
      rotate(transforms.rotation);
      scale(transforms.scaleX, transforms.scaleY);

      // Antennae effect (subtle additional rotation)
      rotate(antennaeAngle * 0.3);

      // DRAW VISIBLE LEG MOVEMENTS for beetles
      // if ((insectType.includes('beetle') || insectType.includes('weavil')) && spriteFrames.length > 0) {
      //   var legConfig = getLegConfiguration(currentFrame, 0);
      //   push(); // Save current transform
      //   // Reset transformations for leg drawing to get clean positions
      //   rotate(-antennaeAngle * 0.3);
      //   scale(1/transforms.scaleX, 1/transforms.scaleY);
      //   rotate(-transforms.rotation);
      //   translate(-transforms.translateX, -transforms.translateY);
      //   rotate(-(vara + radians(90)));
      //   translate(-varx, -vary);
      //   // Draw legs at absolute position with beetle's angle
      //   drawBeetleLegs(varx, vary, vara, legConfig);
      //   pop(); // Restore transform for main sprite
      // }

      var screenVarX = varx - 45;
      var screenVarY = vary - 45;
      let screenX = (screenVarX / windowWidth) * 3160; 
      let screenY = (screenVarY / windowHeight) * 1200;

      socket.emit('imageChange', { 
        x: screenX, 
        y: screenY, 
        rads: vara + radians(90), 
        img: imgUrl,
        insectType: insectType,
        currentFrame: currentFrame,
        behaviorState: behaviorState,
        spriteTint: spriteTint,
        legData: (insectType.includes('beetle') || insectType.includes('weavil')) ? 
                 getLegConfiguration(currentFrame, 0) : null,
        realisticData: {
          bodyTilt: bodyTilt,
          wingPhase: wingPhase,
          walkPhase: walkPhase,
          groundContact: groundContact
        }
      });

      var currentImg = getCurrentFrame();
      var imageToUse = currentImg || img;
      
      var size = 90;
      if (insectType.includes('butterfly')) {
        size = 100;
      } else if (insectType.includes('beetle') || insectType.includes('weavil')) {
        size = 85;
      }
      
      // Apply per-frame offset for beetle
      if ((insectType.includes('beetle') || insectType.includes('weavil')) && spriteFrames.length > 0) {
        var offset = beetleFrameOffsets[currentFrame] || [0, 0];
        translate(offset[0], offset[1]);
      }
      // Apply tint before drawing the sprite
      if (spriteTint) {
        tint(spriteTint[0], spriteTint[1], spriteTint[2]);
      } else {
        noTint();
      }
      image(imageToUse, 0, 0, size, size);
      noTint(); // Reset tint for other drawings

      pop();
    }
  }

body
  #splash-overlay(style='position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0,0,0,0.95); z-index: 9999; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1s ease; opacity: 1;')
    img#splash-logo(src='/static/images/logo-white.svg', alt='Logo', style='width: 180px; max-width: 60vw; margin-bottom: 32px;')
    #splash-instructions(style="color: #fff; text-align: center; font-family: 'Arial Rounded MT Bold', Arial, sans-serif; background: rgba(0,0,0,0.2); padding: 24px 32px; border-radius: 16px; box-shadow: 0 4px 24px rgba(0,0,0,0.12);")
      h2(style='margin: 0 0 12px 0; font-size: 2rem;') Welcome!
      p(style='margin: 0; font-size: 1.2rem;')
        | Move your mouse around the screen.
        br
        | Experience perfectly balanced 3D beetle movement!
  script.
    // Splash screen fade out after 5 seconds
    window.addEventListener('DOMContentLoaded', function() {
      setTimeout(function() {
        const splash = document.getElementById('splash-overlay');
        if (splash) {
          splash.style.opacity = '0';
          splash.style.pointerEvents = 'none';
          setTimeout(() => splash.style.display = 'none', 1000);
        }
      }, 5000);
    });

 